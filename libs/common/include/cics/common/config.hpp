// =============================================================================
// CICS Emulation - Configuration Management
// Version: 3.4.6
// =============================================================================

#pragma once

#include <string>
#include <map>
#include <optional>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <mutex>

namespace cics::config {

/**
 * @brief Configuration manager for runtime settings
 * 
 * Provides hierarchical configuration with environment variable override
 * and file-based persistence.
 */
class ConfigManager {
public:
    static ConfigManager& instance() {
        static ConfigManager inst;
        return inst;
    }

    /**
     * @brief Load configuration from a properties file
     * @param filename Path to configuration file
     * @return true if loaded successfully
     */
    bool load_file(const std::string& filename) {
        std::lock_guard<std::mutex> lock(mutex_);
        std::ifstream file(filename);
        if (!file.is_open()) {
            return false;
        }

        std::string line;
        while (std::getline(file, line)) {
            // Skip comments and empty lines
            line = trim(line);
            if (line.empty() || line[0] == '#' || line[0] == ';') {
                continue;
            }

            auto pos = line.find('=');
            if (pos != std::string::npos) {
                std::string key = trim(line.substr(0, pos));
                std::string value = trim(line.substr(pos + 1));
                // Remove quotes if present
                if (value.size() >= 2) {
                    if ((value.front() == '"' && value.back() == '"') ||
                        (value.front() == '\'' && value.back() == '\'')) {
                        value = value.substr(1, value.size() - 2);
                    }
                }
                config_[key] = value;
            }
        }
        return true;
    }

    /**
     * @brief Save configuration to a properties file
     * @param filename Path to output file
     * @return true if saved successfully
     */
    bool save_file(const std::string& filename) const {
        std::lock_guard<std::mutex> lock(mutex_);
        std::ofstream file(filename);
        if (!file.is_open()) {
            return false;
        }

        file << "# CICS Emulation Configuration\n";
        file << "# Generated by ConfigManager v3.4.6\n\n";

        for (const auto& [key, value] : config_) {
            file << key << "=" << value << "\n";
        }
        return true;
    }

    /**
     * @brief Get a string configuration value
     */
    std::optional<std::string> get_string(const std::string& key) const {
        std::lock_guard<std::mutex> lock(mutex_);
        
        // Check environment variable first (with CICS_ prefix)
        std::string env_key = "CICS_" + to_upper(key);
        std::replace(env_key.begin(), env_key.end(), '.', '_');
        
        const char* env_val = std::getenv(env_key.c_str());
        if (env_val) {
            return std::string(env_val);
        }

        auto it = config_.find(key);
        if (it != config_.end()) {
            return it->second;
        }
        return std::nullopt;
    }

    /**
     * @brief Get a string value with default
     */
    std::string get_string(const std::string& key, const std::string& default_val) const {
        return get_string(key).value_or(default_val);
    }

    /**
     * @brief Get an integer configuration value
     */
    std::optional<int64_t> get_int(const std::string& key) const {
        auto str = get_string(key);
        if (!str) return std::nullopt;
        try {
            return std::stoll(*str);
        } catch (...) {
            return std::nullopt;
        }
    }

    /**
     * @brief Get an integer value with default
     */
    int64_t get_int(const std::string& key, int64_t default_val) const {
        return get_int(key).value_or(default_val);
    }

    /**
     * @brief Get a boolean configuration value
     */
    std::optional<bool> get_bool(const std::string& key) const {
        auto str = get_string(key);
        if (!str) return std::nullopt;
        std::string lower = to_lower(*str);
        if (lower == "true" || lower == "yes" || lower == "1" || lower == "on") {
            return true;
        }
        if (lower == "false" || lower == "no" || lower == "0" || lower == "off") {
            return false;
        }
        return std::nullopt;
    }

    /**
     * @brief Get a boolean value with default
     */
    bool get_bool(const std::string& key, bool default_val) const {
        return get_bool(key).value_or(default_val);
    }

    /**
     * @brief Set a configuration value
     */
    void set(const std::string& key, const std::string& value) {
        std::lock_guard<std::mutex> lock(mutex_);
        config_[key] = value;
    }

    /**
     * @brief Set an integer configuration value
     */
    void set(const std::string& key, int64_t value) {
        set(key, std::to_string(value));
    }

    /**
     * @brief Set a boolean configuration value
     */
    void set(const std::string& key, bool value) {
        std::lock_guard<std::mutex> lock(mutex_);
        config_[key] = value ? "true" : "false";
    }

    /**
     * @brief Remove a configuration value
     */
    void remove(const std::string& key) {
        std::lock_guard<std::mutex> lock(mutex_);
        config_.erase(key);
    }

    /**
     * @brief Check if a key exists
     */
    bool has(const std::string& key) const {
        std::lock_guard<std::mutex> lock(mutex_);
        return config_.find(key) != config_.end();
    }

    /**
     * @brief Clear all configuration
     */
    void clear() {
        std::lock_guard<std::mutex> lock(mutex_);
        config_.clear();
    }

    /**
     * @brief Get all configuration keys
     */
    std::vector<std::string> keys() const {
        std::lock_guard<std::mutex> lock(mutex_);
        std::vector<std::string> result;
        result.reserve(config_.size());
        for (const auto& [key, _] : config_) {
            result.push_back(key);
        }
        return result;
    }

private:
    ConfigManager() = default;
    ConfigManager(const ConfigManager&) = delete;
    ConfigManager& operator=(const ConfigManager&) = delete;

    static std::string trim(const std::string& s) {
        auto start = s.find_first_not_of(" \t\r\n");
        if (start == std::string::npos) return "";
        auto end = s.find_last_not_of(" \t\r\n");
        return s.substr(start, end - start + 1);
    }

    static std::string to_upper(const std::string& s) {
        std::string result = s;
        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
        return result;
    }

    static std::string to_lower(const std::string& s) {
        std::string result = s;
        std::transform(result.begin(), result.end(), result.begin(), ::tolower);
        return result;
    }

    mutable std::mutex mutex_;
    std::map<std::string, std::string> config_;
};

} // namespace cics::config
